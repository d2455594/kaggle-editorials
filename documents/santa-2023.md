---
tags:
  - Kaggle
  - 組合せ最適化
startdate: 2023-12-19
enddate: 2024-02-01
---
# Santa 2023 - The Polytope Permutation Puzzle
https://www.kaggle.com/competitions/santa-2023

**概要 (Overview)**

* **目的:** このコンペティションの目的は、与えられた複数の高次元ポリトープ（多面体/多胞体）の全頂点を巡回する**最短経路**を見つけることです。具体的には、全てのポリトープの頂点を一筆書きで巡り、最後にスタート地点に戻ってくるような頂点の**順列（Permutation）**を求め、その際の総移動距離（経路長）を最小化することが目標となります。これは、有名な「巡回セールスマン問題（Traveling Salesperson Problem - TSP）」の変形版と言えます。
* **背景:** Kaggleの「Santa」コンペティションは、毎年恒例の最適化問題チャレンジであり、多くの場合、大規模な組み合わせ最適化問題がクリスマスに関連したテーマで出題されます。これらの問題は通常、厳密な最適解を見つけることが計算量的に非常に困難（NP困難）であるため、効率的なヒューリスティックアルゴリズムや探索手法を用いて、制限時間内にできるだけ良い（経路長が短い）解を見つけることが求められます。
* **課題:** ポリトープが高次元であること、頂点の総数が非常に多いこと、そして可能な順列の組み合わせが膨大であることから、最適な経路やそれに近い経路を見つけ出すことは計算的に非常に困難です。ポリトープという幾何学的な設定が、問題の構造に何らかのヒントや制約を与えている可能性もあります。タスクは、与えられた全頂点の最適な訪問順序（順列）を見つけ出す**最適化問題**です。

**データセットの形式 (Dataset Format)**

提供される主なデータは、ポリトープを定義する頂点の座標です。

1.  **入力データ (`polytopes.csv`, `puzzle_info.csv` など):**
    * 複数のポリトープの全頂点の座標情報を含むファイル。通常、CSV形式やテキスト形式で提供されます。
    * 各行が1つの頂点に対応し、その頂点のID、属するポリトープのID（もしあれば）、そして各次元の座標値 (`dimension_1`, `dimension_2`, ..., `dimension_N`) が含まれる形式が考えられます。最終的には、全ての頂点が区別なく一つの集合として扱われ、その全体の順列を求めます。
    * **注意点:** これは最適化問題であり、予測モデルを訓練するような従来の機械学習コンペとは異なります。そのため、訓練データとテストデータへの分割はなく、参加者には解くべき問題インスタンス（全頂点の座標）が全て提供されます。

2.  **`sample_submission.csv`**:
    * 提出フォーマットのサンプル。通常、`path` などの列に、訪問する頂点のIDを順序付けたリスト（例: `[0, 5, 2, 10, ... , 3]` のように、全頂点IDを含む順列）を記述する形式となります。

**評価指標 (Evaluation Metric)**

* **指標:** **Total Path Length (総経路長)**
* **計算方法:**
    1.  参加者が提出した頂点の順列（訪問順序）を取得します。
    2.  その順列に従って、連続する頂点間の**ユークリッド距離**を計算していきます。
    3.  順列の最後の頂点から最初の頂点へのユークリッド距離も計算し、経路を閉じます（閉路）。
    4.  これらの全てのユークリッド距離を合計した値が、提出された順列に対するスコア（総経路長）となります。
* **意味:** このコンペティションの目的は総経路長を最小化することなので、このスコア（総経路長）が**小さい**ほど、より良い解（優れた順列）であると評価されます。リーダーボードは、このスコアが最も小さい順にランク付けされます。

要約すると、Santa 2023コンペティションは、与えられた高次元ポリトープ群の全頂点を巡回する最短経路（TSPの変形）を見つける最適化問題です。データは頂点の座標情報であり、参加者は全頂点の最適な訪問順列を提出します。性能は、提出された順列によって計算される総経路長（ユークリッド距離の合計、小さいほど良い）によって評価されます。

---

**全体的な傾向**

上位解法では、複雑な順列パズル（キューブ、グローブ、リース）を解くにあたり、まず問題をより扱いやすい部分問題（キューブの面・エッジ・コーナー、グローブの2行ユニットなど）に分解する戦略が共通して見られました。その上で、パズルの状態を効率的に変化させるための鍵として、**少数のピースのみを動かす短い基本操作シーケンス（1位の「3-rot」、2位・3位の「コンボ」など）**を発見し、活用することに重点が置かれています。これらのシーケンスは、多くの場合、BFS、DFS、または徹底探索を用いた**事前計算**によって大量に生成・保持されています。

探索アルゴリズムとしては、**ビームサーチ**が多くの解法で中核的な役割を担っており、事前計算されたシーケンスや探索中に見つかるコンボを状態遷移に用いています。加えて、双方向探索（3-rot探索やリース小規模問題）や貪欲探索なども、特定のフェーズや問題タイプに応じて効果的に利用されています。

解の質（操作手順の短さ）を高めるための工夫として、既存の操作シーケンスの**途中**に新たな操作（3-rotやコンボ）を**挿入**し、同時に連続する逆操作などを**キャンセル**することで手順を短縮するテクニックが広く採用されています。また、キューブやグローブ特有の**パリティ（置換の偶奇性）**という制約に対処するための専用の修正ステップやルールベースのアプローチが組み込まれている点も特徴的です。

さらに、外部の既存ソルバー（3x3やNxNxNキューブソルバー）の活用や、計算負荷の高い探索処理を高速化するためのマルチスレッディング、効率的なスコア計算実装なども行われています。全体として、問題を適切に分解し、強力な基本操作（3-rot/コンボ）を発見・活用しつつ、効率的な探索アルゴリズムとシーケンス最適化技術、さらには問題固有の制約への対処を組み合わせることで、高精度（短い手数）な解を効率的に見つけ出すアプローチが全体の傾向として挙げられます。

**1位**

- **アプローチ:**
    - キューブとグローブ問題に注力（リースは簡単なビームサーチで解けるため優先度低）。
    - 各操作が多くのピースを動かすため、少数のピース（特に3つ）のみを入れ替える操作シーケンス（**3-rot**）を見つけて利用することが鍵。
    - 特殊なピース（コーナー等）を先に揃え、残りのピース群が偶置換になるよう調整した後、各ピース群（クラスタ）を3-rotで独立に解く戦略。
    - 効率化のため、初期にある程度ピースを揃えてから3-rotを使用。また、既存の操作シーケンスの**途中**に3-rotを挿入し、操作の**キャンセル**を利用して手順を短縮する。
- **アーキテクチャ:** 特筆すべきアーキテクチャの記述はありません。
- **アルゴリズム:**
    - **双方向探索 (Bidirectional Search):** 3-rotシーケンスの探索に使用。
    - **幅優先探索 (BFS):** グローブ問題で3-rotを発見する補助として使用。
- **テクニック:**
    - **3-rot (3要素回転):** キューブとグローブそれぞれで、3つのピースのみを回転させる最短の操作シーケンスを発見し利用。
    - **クラスタ分解:** 移動可能なピースのグループ（クラスタ）ごとに問題を分割して考察。
    - **偶置換制約の利用:** 3-rotは常に偶置換であるため、解く前に各クラスタが偶置換になるよう調整。
    - **段階的解決:** 特殊パーツ解決 → 偶置換調整 → 基本操作で大まかに整列 → 3-rotの途中挿入による最終調整。
    - **操作シーケンスの最適化:** 既存シーケンスの途中への操作挿入、連続する逆操作（例: `ri` と `-ri`）のキャンセルによる短縮。

**2位**

- **アプローチ:**
    - キューブ/グローブ: 少数のピースのみを動かす短い操作シーケンス（**コンボ**）を発見し、それらを既存の解法シーケンスの**途中**に挿入することで、効率的に不一致ピース数を減らす。
    - リース: 小規模問題は双方向探索。大規模問題（特にワイルドカード付き）はハンガリアンパズルに似た特定アルゴリズムで解く。
- **アーキテクチャ:** 特筆すべきアーキテクチャの記述はありません。
- **アルゴリズム:**
    - **徹底探索 (Exhaustive Search):** 短い「コンボ」を発見するために使用。
    - **貪欲探索 (Greedy Search) / ビームサーチ (Beam Search):** コンボを挿入して不一致を減らすステップで使用。
    - **幅優先探索 (BFS):** キューブの中心ピースの位置合わせに使用。
    - **双方向探索 (Bidirectional Search):** 小規模なリース問題の最適解探索に使用。
- **テクニック:**
    - **コンボ (Combo):** 3つや4つのピースのみを動かす短い（8手以内など）操作シーケンス。
    - **操作シーケンスの途中挿入:** 共役（conjugate: `g.f.g^-1`）の考え方を用いて、シーケンスの任意の位置への操作挿入を効率的にシミュレーション。
    - **操作のキャンセル:** 途中挿入の結果生じる `f0.-f0` のような連続する逆操作を削除し、シーケンスを短縮。
    - **キューブ:**
        - **段階的解決パイプライン:** 色変更前処理 → コンボ挿入による不一致削減 → 中心ピース・パリティ修正 → 24/48ピース部分問題解決 → コーナーピース解決。
        - **パリティ問題への対処:** 特定層の回転操作や、経験的に発見した2つの表面回転の組み合わせで、コンボでは解決できないパリティ（奇置換/偶置換）の問題を修正。
        - **24/48ピース問題:** キューブの対称性を利用し、特定のピースグループ（24個または48個）を独立した部分問題としてコンボを用いて解決。
        - **コーナーピース解決:** 外部の最適ソルバー（NxNxN-solver, TPR-4x4x4-Solver）を利用。
    - **グローブ:**
        - **段階的解決パイプライン:** コンボ挿入による不一致削減 → パリティ修正 → コンボ適用による全ピース配置 → 難問対応。
        - **パリティ問題への対処:** 特定列（r0, r(k-1)）の回転や半球回転（fi）が奇置換/偶置換になる性質を利用して修正。
        - **難問対応:** 特定の難インスタンス（391, 395）では、3ピース回転のコンボを網羅的に生成・適用して解決。
    - **リース:**
        - **小規模:** 双方向探索。状態を128ビット整数にエンコードしてメモリ効率化。
        - **大規模:** ハンガリアンパズルに似た戦略。特定順序でセルの色を修正。ランダムな前処理ステップを追加して総ステップ数を削減。

**3位**

- **アプローチ:**
    - すべての問題タイプ（キューブ、グローブ、リース）で**ビームサーチ**を一貫して使用。
    - ビームサーチの状態遷移には、主に**事前計算**した、少数のピースのみを変更する短い操作シーケンス（DFS/BFSで発見）を利用。
- **アーキテクチャ:** 特筆すべきアーキテクチャの記述はありませんが、ビームサーチの高速化のために**マルチスレッディング**（最終的に180スレッド）を活用。
- **アルゴリズム:**
    - **ビームサーチ (Beam Search):** 全問題タイプにおける主要探索アルゴリズム。
    - **深さ優先探索 (DFS):** 操作シーケンスの事前計算、リース問題の評価関数計算（先読み）に使用。
    - **幅優先探索 (BFS):** 操作シーケンスの事前計算に使用。
    - **動的計画法 (DP):** グローブ問題で、独立に解いたユニット（2行単位）の解を結合・最適化する際に使用（LCS問題類似）。
- **テクニック:**
    - **操作シーケンスの事前計算:**
        - DFS/BFSを用いて短い（8～10手以内）かつ変更ピース数の少ないシーケンスを大量に生成。
        - 重複削除（同じ盤面変化なら最短手数、同手数なら辞書順最小）。
        - シーケンスの拡張（既存シーケンスXを A.X.-A の形で拡張）。
        - キューブ問題では巨大なメモリ（200GB超）を要するほどのシーケンスを保持。
    - **ビームサーチの最適化:**
        - スコア計算の効率化。
        - マルチスレッディングによる並列化。
        - 評価関数: 基本はハミング距離。キューブでは揃えにくいピースの重みを増加。
    - **キューブ:**
        - 面とエッジを分離し、それぞれビームサーチで解決。
        - "Parallelize"（並列化）: 状態遷移時に、既存シーケンスに類似操作を追加して試行（例: f0.r2.b0 を f0.r2.r1.b0 に変更）。
        - エッジのパリティ調整（ルールベースで別途処理）。
        - 最終的な3x3部分の解決にはQTM（四半回転）最適ソルバー（Kociemba）を使用。
    - **グローブ:**
        - 2行単位で独立にビームサーチで解き、後で結合。
        - 結合時にDPを用いて、複数ユニットで共通して実行できる操作をまとめ、シーケンスを短縮。
        - 特殊なグローブ（全ピース色が異なる場合）でのパリティ調整。
    - **リース:**
        - 小規模は公開コード（徹底探索ベース）を利用。
        - 大規模はビームサーチ。評価関数計算のためにDFSで一定手数先まで探索（先読み）。状態遷移時の操作を制限（連続逆操作禁止、交差部分の状態に応じた操作制限）して探索効率を向上。スコア関数はリングごとの不一致やCの位置関係を考慮（ワイルドカードが多い場合はC関連ペナルティを緩和）。十分な探索深度の確保が重要。
