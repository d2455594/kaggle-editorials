---
tags:
  - Kaggle
  - 組合せ最適化
  - ビームサーチ
  - SimulatedAnnealing
startdate: 2024-11-22
enddate: 2025-02-01
---
# Santa 2024 - The Perplexity Permutation Puzzle
[https://www.kaggle.com/competitions/santa-2024](https://www.kaggle.com/competitions/santa-2024)

**概要 (Overview)**

* **目的:** このコンペティションの目的は、与えられた単語リストについて、特定のルール（単語間に "and" を挿入）に従って生成されるテキストの**パープレキシティ (Perplexity)** が最小となるような**単語の順列（permutation）を見つける**ことです。
* **背景:** 毎年恒例のSantaコンペティションであり、今回は自然言語処理で用いられる評価指標「パープレキシティ」を目的関数とした組み合わせ最適化問題です。Gemmaという大規模言語モデル（LLM）がテキストの自然さを評価するために使用されました。
* **課題:** 単語リストの順列の数は、単語数が増えると階乗的に爆発的に増加するため、全ての順列を試すことは不可能です。また、各順列の評価（パープレキシティ計算）にはGemmaモデルの推論が必要であり、計算コストが高いという制約がありました。そのため、広大な探索空間から効率的に最適解（またはそれに近い解）を見つけ出すための高度な最適化アルゴリズムやヒューリスティクスが求められました。

**データセットの形式 (Dataset Format)**

提供される主なデータは、パズル定義ファイルと提出サンプルファイルです。

1.  **`puzzle_info.json`**:
    * 6つのパズル（ID 0から5）に関する情報が含まれるJSONファイル。
    * 各パズルID (`puzzle_0` から `puzzle_5`) をキーとして、そのパズルで使用される単語のリストが値として格納されています。単語数はパズルによって異なり、10個から100個まで様々です。
2.  **`sample_submission.csv`**:
    * 提出フォーマットを示すCSVファイル。
    * `id`: パズルID (0から5)。
    * `permutation`: 該当するパズルIDの単語リストに対する、単語インデックス（0から始まる）の順列をスペース区切りで記述します。例えば、単語リストが `["a", "b", "c"]` で、順列が `c b a` であれば、`2 1 0` と記述します。

**評価指標 (Evaluation Metric)**

* **指標:** **パープレキシティ (Perplexity)**
* **計算方法:**
    1.  参加者が提出した各パズルIDに対する単語インデックスの順列を取得します。
    2.  その順列に従って単語を並べ、単語間に "and" を挿入してテキストを生成します (例: `word1 and word2 and ... and wordN`)。
    3.  生成されたテキストを、指定されたGemma言語モデル（`kaggle/gemma/jax/2b`）に入力し、パープレキシティを計算します。
    4.  コンペティション全体のスコアは、全6パズルに対するパープレキシティの合計値です。
* **意味:** パープレキシティは、言語モデルがそのテキスト系列をどれだけ尤もらしい（予測しやすい）と評価しているかを示す指標です。値が**低い**ほど、そのテキストはモデルにとってより「自然」で流暢であると見なされます。このコンペでは、単語の並び順を最適化することで、Gemmaモデルにとって最も自然に見える（＝パープレキシティが最小になる）テキストシーケンスを発見することが目標となります。スコアは**低い**ほど良い評価となります。

---

**全体的な傾向**

この単語順列最適化問題では、目的関数であるパープレキシティの計算に計算コストのかかるLLM推論が必要なため、効率的な探索アルゴリズムが不可欠でした。上位解法の多くは、**シミュレーテッドアニーリング (Simulated Annealing, SA)** や**反復局所探索 (Iterated Local Search, ILS)** などのメタヒューリスティクスを採用していました。遺伝的アルゴリズム (GA) も一部で使用されました。

探索の中心となるのは、現在の解（単語の順列）を少しだけ変更して新しい候補解を生成する**近傍探索**です。用いられた主な**近傍操作 (Tweak/Move)** には、2つの単語の位置を入れ替える**スワップ (Swap)**、単語または連続する単語群（フレーズ）を別の位置に**削除＆挿入 (Remove & Insert)** する操作（TSPにおけるk-optの一部に相当）、2つのフレーズを入れ替える操作（TSPにおけるDouble Bridge Moveに類似）などがありました。探索の進行度合いや問題サイズに応じて、適用する近傍操作の種類や範囲を調整する戦略も見られました。

探索の出発点となる**初期解**の選択も重要でした。単純なランダム順列やアルファベット順ソートに加え、「**ストップワード**」（"the", "a", "is" など、文法的な機能を持つが意味内容は薄い単語）を文頭に集め、残りの単語をアルファベット順にソートする戦略が特に有効であることが広く認識されました。さらに、ストップワード以外の単語を品詞（動詞など）や意味でグループ分けしてソートするアプローチも、特に単語数の多い問題（サンプル5）で効果を発揮しました。

探索アルゴリズムの効率と性能を高めるために、様々な工夫が凝らされました。SAにおいては、**温度管理**（冷却スケジュール）の調整や、局所最適解から脱出するための**再加熱 (Warmup)** などが行われました。ILSでは、局所最適解に陥った際に適用する**摂動 (Perturbation / Kick)** の強度や方法が重要でした。また、複数の探索パスを並行して実行し、多様性を維持する戦略（Multi Point Search）も採用されました。

計算コストの高いパープレキシティ評価を効率化するため、**スコアキャッシュ**（計算済みの順列とそのスコアを記録）の利用が一般的でした。キャッシュの効率的な管理（キーのバイナリエンコード、msgpack利用など）も重要でした。また、多数の候補解を生成し、GPUを用いて**バッチ処理**で評価する手法も広く用いられました。一部のチームでは、2-gram情報などを用いた**近似的な評価関数**を作成し、候補解を事前に枝刈り（Pruning）する試みも行われました。

**各解法の詳細**

**[1位](https://www.kaggle.com/competitions/santa-2024/discussion/560560)**

* **アプローチ:** 全てのパズルに共通の戦略としてビームサーチを使用。状態遷移には、少数の単語のみを動かす短い操作シーケンス（DFS/BFSで事前計算）を主に使用。
* **アーキテクチャ/アルゴリズム:**
    * **コンボ探索:** DFS/BFSで短い手数（8-9手以下）で少数の単語のみを動かすシーケンスを事前計算し、重複除去。
    * **解探索:** ビームサーチ。評価関数は目標状態とのハミング距離（ミスマッチ数）を基本とし、調整（難しい単語の重み増など）。
* **テクニック:**
    * **高速化:** スコア計算の効率化、マルチスレッド化。
    * **状態遷移:** 事前計算したコンボに加え、「並列化」遷移（例: `f0.r2.b0` を `f0.r2.r1.b0` に変更）も試行。
    * **Cube特化:** 面とエッジを分離してビームサーチ。パリティ調整は別処理。最終段階は3x3ソルバー（QTM最適）。
    * **Globe特化:** 2行単位で独立に解き、後でDPを用いて結合（操作の並列化を考慮）。パリティ調整。
    * **Wreath特化:** 小サイズは最適解探索。大サイズはビームサーチ＋深さ制限付きDFS評価。探索深度確保のため状態に応じた操作制限。

**[2位](https://www.kaggle.com/competitions/santa-2024/discussion/560540)**

* **アプローチ:** 局所探索＋キック（局所最適解からの脱出）の組み合わせ。基本的には Iterated Local Search (ILS) に近い。
* **アーキテクチャ/アルゴリズム:** 局所探索 (Local Search) + キック操作 (Kick Operation)。
* **テクニック:**
    * **近傍操作 (Local Neighborhood):**
        * (1) 単一単語の削除＆挿入（限定的な3-opt）。
        * (2) フレーズ（連続する複数単語）の削除＆挿入（ほぼ3-opt）。
        * (3) 2つのフレーズのスワップ（Double-bridge kick）。
        * 問題サイズに応じて使用する近傍の種類を使い分け（小: (3), 中: (2)たまに(3), 大: (1)たまに(2)）。
    * **局所探索:** 定義された近傍内でより良い解が見つからなくなるまで探索。
    * **キック操作:** 局所最適解に陥った場合に、解の一部をランダムに入れ替えたり、解の前方部分を後方に移動させたり、近傍操作を数回適用したりして探索を再開。探索履歴を遡って別の分岐を試す戦略も使用。
    * **問題3特化:** 最後の単語を固定して局所最適解を複数生成し、探索空間を広げる。
    * **問題5特化:** 問題1, 3, 4の解を組み合わせて初期解を生成。チームメイトによるカスタムキックで最終解へ。
    * **動作しなかった手法:** SA、Late Acceptance Hill Climbing、フレーズ単位での分割統治/ブルートフォース、Branch and Bound、Multi-Arm Bandit。

**[3位](https://www.kaggle.com/competitions/santa-2024/discussion/560620)**

* **アプローチ:** シミュレーテッドアニーリング (SA) をベースとし、候補解生成方法に工夫を加えた2つのアプローチ。
* **アーキテクチャ/アルゴリズム:** Simulated Annealing (SA)。
* **テクニック:**
    * **バッチ処理:** 複数の候補解のスコアをGPUで一括計算。
    * **カスタム候補生成 (アプローチ1):**
        * 複数の近傍操作（swap, reverse, remove-insertなど）を定義。
        * 各操作の過去の性能（スコア改善度）に基づいて、操作を選択する確率（重み）を動的に更新するシステム。単語自体の重要度（パープレキシティへの影響）も考慮。
    * **SA拡張 (アプローチ1):** 過去の操作スコアの追跡と重み更新。同スコア最良解の考慮（A100 GPU等で見られる現象への対応）。改善が見られない場合の探索リセット/再開。
    * **初期解:** アルファベット順ソート、ストップワード分離ソート、ランダムスタート、**「ソート済みストップワード + ソート済み動詞 + ソート済みその他単語」**（特に問題5で有効）。
    * **追加操作 (アプローチ2):** より多くの近傍操作（BlockMove, BlockSwap, ReverseBlock, ShuffleBlock, CyclicShift, TripleMove, Interleaveなど）を追加。
    * **SA拡張 (アプローチ2):** 周期的な冷却、許容エネルギー範囲の制限、トップk解の並行探索/選択、操作重み付け。
    * **戦略:** ある実行で得られた最良解を、別の設定（操作の種類を限定するなど）の初期解として再利用。

**[4位](https://www.kaggle.com/competitions/santa-2024/discussion/560536)**

* **アプローチ:** 反復局所探索 (Iterated Local Search, ILS)。「挿入最適化 (Insert optimize)」と「局所最適化 (Local optimize)」のループ。
* **アーキテクチャ/アルゴリズム:** Iterated Local Search (ILS) = (Beam Search based Insertion + Local Optimization Loop)。
* **テクニック:**
    * **挿入最適化:** ランダムに選択したN個の単語を削除し、ビームサーチを用いて最適な位置に再挿入する。
    * **局所最適化:** 改善が見られなくなるまで以下の操作を繰り返す：部分列のシャッフル、単語スワップ、単語移動。同一配置の除外、重複削除。
    * **発見1 (Valid Length):** 特定の単語群（reindeer, jingle, sleighなど）を文頭に置くと有利（モデルがより長いシーケンスを有効と見なす？）。問題3では "magi" で始めると高速に解が見つかる。
    * **発見2 (Stop Words):** ストップワード（機能語）を文頭にまとめるとスコアが下がる傾向。問題4の最適解は「機能語 + 内容語（ソート済）」。問題5は「機能語 + 内容語1（ソート済） + 内容語2（ソート済）」。
    * **問題5特化:** 機能語リストから "and" を除外するとさらに改善。

**[5位](https://www.kaggle.com/competitions/santa-2024/discussion/560597)**

* **アプローチ:** シミュレーテッドアニーリング (SA) の変種。Multi Point Search と ATSP (非対称巡回セールスマン問題) に触発された近傍操作。
* **アーキテクチャ/アルゴリズム:** Simulated Annealing (SA) variant with Multi Point Search。
* **テクニック:**
    * **Multi Point Search:** GPU効率化のため、N個のSA探索を並列実行。各ステップでN個の解からN個の近傍解を生成し、バッチ評価。スコアが良いもの、または現在の最良スコア+マージン内のものを保持。それ以外は最良解とのクロスオーバー（限定的なGA要素）で生成した解を保持。多様性を維持。
    * **近傍操作 (Moves):**
        * **k-opt:** シーケンスをk個のセグメントに分割し、シャッフルして再結合。
        * **Remove-Insert:** 部分列（長さk）を削除し、最適な位置に再挿入。
        * **Double Root and Stem:** ATSPヒューリスティクスからの着想。シーケンスをグラフ構造（2サイクル+パス or 3パス）に変換し、特殊な操作を加えてからシーケンスに戻す。
    * **高速化:** グローバルスコアキャッシュ（キー: テキスト、値: スコア）を利用。
    * **割引パープレキシティ (Discounted Perplexity):** 各トークン位置での平均ロジット値を計算し、個々のテキストのロジット値をこれで割って正規化。この割引スコアをSAの受理判断に使うことで、文頭付近の変更も文末付近と同等に評価されるようにし、探索の停滞を防ぐ。
    * **動作しなかった手法:** Sinkhorn層やATSPソルバーを用いた勾配ベース/反復最適化、MCTS+RL。

**[7位](https://www.kaggle.com/competitions/santa-2024/discussion/561091)**

* **アプローチ:** 反復局所探索 (ILS) とシミュレーテッドアニーリング (SA) の組み合わせ。「Repeat SA Search」による局所探索と、ランダムシャッフルによる摂動（キック）。
* **アーキテクチャ/アルゴリズム:** Iterated Local Search (ILS) with Repeated Simulated Annealing (SA) as local search。
* **テクニック:**
    * **SA:** 基本的なSA。近傍操作 (tweak) として挿入、スワップ、局所シャッフル。
    * **バッチ近傍探索:** 一度に多数 (k=1000-5000) の近傍解を生成し、バッチ評価。最良解を受理、そうでなければ確率的にトップ10から準最適解を受理。
    * **Repeat SA Search:** SA探索を複数回繰り返し、回数を重ねるごとに温度ステップあたりの試行回数を増やして探索を細かくする。早期停止機構あり。
    * **ILS:** Repeat SA Searchで局所最適解に達したら、ランダムに`perturb_rank`個の単語をシャッフルして摂動を与え、探索を再開。`perturb_rank`の大きさは探索の成功/失敗に応じて動的に調整。
    * **効率化:** スコアキャッシュ（単語を整数エンコード→バイナリ表現、msgpackでディスク保存）。
    * **枝刈り (Pruning):** 2-gram情報に基づく距離行列を作成（過去の局所最適解に含まれる2-gramの距離を低く設定）。近傍解生成後、この距離行列を使って候補解を事前評価し、有望なものだけを実際のパープレキシティ計算にかけることで探索効率を100倍程度改善。
    * **距離行列の動的更新:** 探索中に見つかった良い解（低パープレキシティ）に含まれる2-gram情報を使って、距離行列を動的に更新。

**[9位](https://www.kaggle.com/competitions/santa-2024/discussion/560601)**

* **アプローチ:** Edge Assembly Crossover (EAX) を用いた遺伝的アルゴリズム (GA-EAX)。初期集団はSAで生成。局所探索も併用。
* **アーキテクチャ/アルゴリズム:** Genetic Algorithm with Edge Assembly Crossover (GA-EAX) + Local Search (SA)。
* **テクニック:**
    * **初期集団:** SAで生成。
    * **交叉 (Crossover):** EAX (ATSP用手法を適用)。ABサイクルの選択は "EAX-1AB"。順列の再構成時には、親個体のGemma出力ロジットを利用し、パープレキシティが下がりそうなエッジ（隣接単語ペア）を選択。
    * **選択:** 親個体と、それに近い子個体を比較し、改善されていれば置き換える ("SEL1")。集団の多様性を維持するため、類似個体にペナルティ。一度淘汰された個体もスコアに応じて再利用。
    * **局所探索:** 子個体に対してSAや3-optなどの局所探索を適用。
    * **初期解/近傍操作:**
        * ID=0-3: ランダム初期解、ランダム3-opt。
        * ID=4: ストップワード先頭配置、ランダム3-opt。
        * ID=5: ストップワード先頭 + 残りを2分割ソート。近傍操作はグループ構造を維持しつつグループ間移動を優先。EAXではグループ破壊も許容。
    * **利点:** GA-EAXとLLMロジットの組み合わせが有効。参考文献の手法が集団多様性の維持と最適化に有効。

**[10位](https://www.kaggle.com/competitions/santa-2024/discussion/560531)**

* **アプローチ:** シミュレーテッドアニーリング (SA) のみを使用。初期解の選択とSAパラメータ制御が鍵。
* **アーキテクチャ/アルゴリズム:** Simulated Annealing (SA)。
* **テクニック:**
    * **初期解:** 非常に重要。特に問題5では「[stopwords (and除く)] + [ソート済みブロック1] + [and and and...] + [ソート済みブロック2]」（ブロックはランダム分割）が有効だった。
    * **近傍操作:** 2単語スワップと、単語の削除＆挿入の2種類のみを最終的に使用。ストップワード限定の操作も試行（初期には有効）。Cyclic Rotationも試行。複雑な近傍操作は効果なしと判断。
    * **SA制御:** 温度管理（初期/最終温度、冷却スケジュール）、温度ごとの反復回数、受理率の監視などを通じてアルゴリズムの挙動を理解し制御。
    * **SA実行タイプ:** (a) 高温探索（広域探索）、(b) Warmup（局所最適解脱出）、(c) 低温探索（局所最適解近傍の詳細探索）の3タイプを使い分ける。
    * **計算資源:** 高速な実験とパラメータ調整に重要。
