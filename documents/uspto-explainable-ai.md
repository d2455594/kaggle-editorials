---
tags:
  - Kaggle
  - SimulatedAnnealing
  - ビームサーチ
  - Woosh
startdate: 2024-04-25
enddate: 2024-07-25
---
# USPTO - Explainable AI for Patent Professionals
[https://www.kaggle.com/competitions/uspto-explainable-ai](https://www.kaggle.com/competitions/uspto-explainable-ai)

**概要 (Overview)**

* **目的:** このコンペティションの目的は、米国特許商標庁（USPTO）の特許専門家（審査官など）が特定の技術分野における先行技術文献（関連特許）を効率的に検索するための支援となる、**効果的な検索クエリを自動生成する**AIモデルを開発することです。副次的な目的として、生成されたクエリの**説明可能性**も考慮されます（ただし評価指標には直接反映されません）。
* **背景:** 特許出願の審査においては、新規性や進歩性を判断するために、広範な先行技術調査が不可欠です。関連する特許文献を網羅的かつ迅速に見つけ出すことは、審査の質と効率を左右する重要なプロセスです。AI技術を活用することで、この検索プロセスを自動化・支援し、専門家の負担を軽減することが期待されています。
* **課題:** 各ターゲット特許（検索の中心となる特許）に対して、その技術内容を的確に捉え、指定された50件の類似特許（正解ターゲット）を検索結果の上位にランクインさせ、かつ無関係な特許（非ターゲット）を可能な限り排除するような**検索クエリ文字列を生成する**必要があります。検索エンジンWhooshのクエリ言語（AND, OR, NOT, フレーズ検索、フィールド指定 `ti:`, `ab:`, `cpc:` など）の特性を理解し、**最大50トークン**という制限の中で最適なクエリを構築することが求められました。特に、高い再現率（多くのターゲットを検索する）と高い適合率（非ターゲットを検索しない）を両立させることが困難な課題でした。

**データセットの形式 (Dataset Format)**

提供される主なデータは、特許間の類似性情報、特許メタデータ、およびWhoosh検索エンジン用インデックスです。

1.  **`train.csv`, `test.csv`**:
    * 各行が1つの検索タスクに対応します。
    * `publication_number`: 検索の基点となる特許（アンカー特許）の公開番号。
    * `target`: `publication_number`に類似すると判定された50件の特許公開番号のリスト（セミコロン区切り）。これが検索で取得すべき正解リストです。
    * `anchor`: アンカー特許のテキストの一部（詳細不明）。
    * `context`: アンカー特許の技術分類コード（CPCコード）。
2.  **`patent_metadata.parquet`**:
    * 約1300万件の特許文献に関するメタデータ。
    * `publication_number`: 特許公開番号。
    * `publication_date`: 公開日。
    * `title`: タイトル（発明の名称）。
    * `abstract`: 要約。
    * `claims`: 特許請求の範囲のテキスト（古い特許では欠損の場合あり）。
    * `description`: 発明の詳細な説明のテキスト（古い特許では欠損の場合あり）。
    * `cpc_codes`: 特許分類コード（CPC）のリスト。
3.  **`patent_detailed_text.parquet`**: (詳細不明、`patent_metadata.parquet`のdescription/claimsの補完または詳細版か？)
4.  **`train_index/`, `test_index/`**:
    * Whoosh検索エンジン用のインデックスファイル。
    * `train_index` はトレーニングデータに関連する特許、`test_index` は `test.csv` に関連する特許（ターゲットおよび非ターゲット候補を含む）のみを含みます。この`test_index`に対して生成したクエリを実行し、結果を評価します。
5.  **`sample_submission.csv`**:
    * 提出フォーマットのサンプル。`publication_number` と `query`（生成されたWhoosh検索クエリ文字列）の列を持ちます。

**評価指標 (Evaluation Metric)**

* **指標:** **Average Precision @ 50 (AP@50)**
* **計算方法:**
    1.  各`publication_number`に対して生成された`query`を、対応する`test_index`で検索し、上位50件の結果リストを取得します。
    2.  このリスト中に、その`publication_number`に対応する50件の正解`target`特許がどれだけ含まれているか、またその順位に基づいてAverage Precisionを計算します。
        * Precision@k = (上位k件中の正解ターゲット数) / k
        * AP@50 = (1 / min(50, 全ターゲット数=50)) * Σ_{k=1}^{50} (Precision@k * I(k番目がターゲット))
        （I(condition)はconditionが真なら1、偽なら0）
    3.  全テストサンプルに対するAP@50の平均値が最終スコアとなります。
* **意味:** 検索結果のランキング品質を評価する指標です。検索結果の上位に、より多くの正解ターゲットが含まれているほど、また、正解ターゲットがより上位にランクインしているほどスコアが高くなります。特に、**検索結果に非ターゲット（False Positive）が含まれないクエリが高スコアを得やすい**傾向がありました。スコアは**高い**ほど良い評価となります。

---

**全体的な傾向**

このコンペティションでは、効果的な検索クエリを生成するために、Whoosh検索エンジンの特性を理解し、それを最大限に活用する戦略が求められました。特に、コンペ期間中に発見された**Whooshのトークンカウントに関する「マジック」（ハック）** が上位スコア獲得の鍵となりました。

この「マジック」は、特定の記述方法を用いることで、**実質的に複数の単語やフィールド指定を含む検索条件を、Whooshのトークンカウンター上は1トークンとして扱わせる**テクニックです。例えば、`ti:"word1"ab:"word2"`や`ti:word1-word2`、`ti:"word1~word2"`（`~`は特殊な空白文字）といった形式を用いることで、AND結合された複数の条件を少ないトークン数で表現できました。これにより、トークン数制限（50）の中で非常に多くの検索条件を組み合わせた強力なクエリを作成することが可能になり、スコアが劇的に向上しました。

このマジックを活用した上位解法の多くは、以下の戦略を取りました。
1.  **高精度サブクエリ候補の生成:** まず、特定のターゲット特許（1つまたは少数）のみをヒットさせ、非ターゲット（False Positive）を全く含まないような**サブクエリ**を大量に生成します。これには、ターゲット特許群に共通する単語（特に低頻度語）やCPCコードの組み合わせが用いられました。全特許データ（約1300万件）に対する**自前の転置インデックス**を構築し、高速な検索（C++実装やcupy利用）を行うことで、FP=0を保証するサブクエリを効率的に探索しました。
2.  **サブクエリの選択と結合:** 生成された多数のサブクエリ候補の中から、与えられた50件のターゲット特許をできるだけ多くカバーし、かつトークン数制限（マジック利用で緩和される）を満たす最適な組み合わせを選択します。この組み合わせ最適化問題に対して、**シミュレーテッドアニーリング (SA)**、**整数計画問題ソルバー (MIP)**、**貪欲法 (Greedy Algorithm)**、**ビームサーチ (Beam Search)** などが用いられました。最終的なクエリは、選択されたサブクエリを `OR` で結合する形が一般的でした。

マジックを使用しないアプローチでは、SAなどを用いてクエリ文字列を直接最適化する試みがありましたが、マジック利用解には及ばなかったようです。

クエリに含める単語やCPCコードの選択においては、ターゲット特許群に共通して出現し、かつ他の特許にはあまり出現しない（**IDFが高い**）ものが重視されました。頻出単語は多くの場合除外されました。

**各解法の詳細**

**[1位](https://www.kaggle.com/competitions/uspto-explainable-ai/discussion/522233)**

* **アプローチ:** シミュレーテッドアニーリング (SA) を用いてサブクエリを選択し、ORで結合。AND結合はマジック（ハイフン連結）を使用。
* **アーキテクチャ/アルゴリズム:** シミュレーテッドアニーリング (SA)。
* **テクニック:**
    * **クエリ形式:** `(field:word1-word2-...) OR ...` の形式。ANDはハイフンで表現。ORのみ使用。CPCはハイフン連結できないため最後に配置。
    * **単語選択:** CPC/Title/Abstractは全単語使用。Claim/Descriptionは高頻度語（出現数10万以上）を除外。
    * **サブクエリ候補生成:** 単一ターゲットが持つ全単語、または2ターゲット間の共通単語集合をベースとする。単語を出現特許数の昇順に追加し、非ターゲットが含まれなくなった時点でサブクエリ候補とする。高速化のためcupy (cp.intersect1d) を使用。
    * **SA:** 近傍操作は「未使用サブクエリを1つ追加」または「使用中サブクエリを1つ削除」。スコアリングはターゲットカバー数のみ（候補生成時点でFP=0のため）。ターゲット集合が同じサブクエリは重複削除。

**[2位](https://www.kaggle.com/competitions/uspto-explainable-ai/discussion/522258)**

* **アプローチ:** 「マジック」（空白なしAND）を利用。サブクエリ候補を生成し、貪欲法（+ビームサーチ）で選択してOR結合。非ターゲットをキャンセルするNOTクエリも使用。
* **アーキテクチャ/アルゴリズム:** 貪欲法、ビームサーチ。カスタムC++検索エンジン。
* **テクニック:**
    * **クエリ形式:** `(subquery1 OR subquery2 OR ...) NOT (negative_subquery1 OR ...)`。サブクエリ内はマジック（空白なしAND）を使用。
    * **評価指標考察:** メトリックの性質上、FP=0のクエリが非常に高スコアになることを重視。
    * **インデックス構築:** 全特許データから自前の転置インデックスをC++で構築（メモリ効率化のためID化）。Claim/Descriptionは高頻度語を除去しデータ削減。
    * **サブクエリ候補生成:** 単一ターゲットまたはペアターゲットの共通語から、FP=0となるような単語の組み合わせ（AND結合）を探索。特許数の少ない単語から順に共通集合を取り、非ターゲットが除去された時点で候補とする。非ターゲットが残った場合は、それを除去するNegativeサブクエリも同時に探索。
    * **サブクエリ選択:** 全ターゲットをカバーするように、スコア（新規カバーターゲット数 - カバー済みターゲットの希少性ペナルティ）最大のサブクエリを貪欲に追加。最終的にビームサーチで微調整。

**[3位](https://www.google.com/search?q=https://www.kaggle.com/competitions/uspto-explainable-ai/discussion/522239)**

* **アプローチ:** 「マジック」（ハイフン連結AND）を利用。少数のターゲット集合に対する共通トークンからサブクエリ候補を生成し、MIPソルバーで最適な組み合わせを選択。
* **アーキテクチャ/アルゴリズム:** Mixed Integer Programming (MIP) ソルバー。カスタムC++検索エンジン（マルチスレッド）。
* **テクニック:**
    * **クエリ形式:** `(field:token1-token2-...) OR ...` の形式。
    * **サブクエリ候補生成:** 小さなターゲット部分集合（サイズ<=3）に対する共通トークン（Title, Claim, CPC全体、Abstract/Descriptionは低頻度10万語）をAND連結したものを候補とする。
    * **サブクエリ選択:** MIPソルバーを用いて、トークン数制限内でターゲットカバー数を最大化するサブクエリの組み合わせを決定。評価は自作テストインデックス上でのターゲットヒット数に基づく。
    * **高速化:** C++実装、マルチスレッド、アルゴリズム最適化。

**[4位](https://www.kaggle.com/competitions/uspto-explainable-ai/discussion/522200)**

* **アプローチ:** 「マジック」（フィールド+引用符+連結）を利用。ターゲットペアの共通トークンをAND連結したサブクエリをORで結合。
* **アーキテクチャ/アルゴリズム:** 貪欲法？ + ペアマッチング。
* **テクニック:**
    * **クエリ形式:** マジック `field:"token1"field:"token2"...` を利用し、複数フィールド/単語のAND結合を1トークンで表現。これらのサブクエリをORで結合。
    * **サブクエリ生成:** ターゲット特許を25ペアに分割。各ペアについて、共通トークンを（出現頻度の降順に）最大25個AND連結したものをサブクエリ候補とする。
    * **サブクエリ選択:** 生成したペアワイズサブクエリが、テストインデックスでペア以外の特許をヒットしないか確認し、ヒットする場合は不採用。未使用ターゲットが残った場合、シングルヒットするサブクエリ（低頻度語のみ使用）を追加。最後に、トークン数上限まで共通トークンを追加。
    * **ペアマッチング:** どのターゲット同士をペアにするかは、共通トークンの出現確率の積に基づいて決定？
    * **マジックなし解法:** SAを用いて `cpc:CPC1(token1 OR ...) OR ... OR (tokenN OR ...)` 形式のクエリを最適化（AP@50期待値を評価関数に）。LevelDBやファイル圧縮などデータハンドリングに工夫。

**[5位](https://www.kaggle.com/competitions/uspto-explainable-ai/discussion/522201)**

* **アプローチ:** 「マジック」（空白なしAND、特殊文字スペース）を利用。Global Counter候補と50c2候補を生成し、整数計画問題ソルバーで最適な組み合わせを選択。
* **アーキテクチャ/アルゴリズム:** 整数計画問題 (ILP) ソルバー (Python)。
* **テクニック:**
    * **クエリ形式:** マジックを利用し、AND結合サブクエリのトークン数を1にする。サブクエリはORで結合。
    * **評価指標考察:** FP=0を最重視する戦略。
    * **候補生成 (Global Counter):** 全特許中の単語/N-gram出現数を事前計算。50ターゲット中に出現する各単語/N-gramについて、ヒットするターゲット数(TP)と非ターゲット数(FP)を計算し候補とする。
    * **候補生成 (50c2):** ターゲット50件から2件のペア(1225通り)を選び、共通単語をAND連結したクエリを作成。IDFの合計値が閾値(80)以上ならFP=0と推定し候補とする。
    * **サブクエリ選択:** 上記2種類の候補から、トークン数50以下で `10*TP - FP` を最大化する組み合わせをILPソルバーで選択。

**[6位](https://www.kaggle.com/competitions/uspto-explainable-ai/discussion/522202)**

* **アプローチ:** 「マジック」（空白なしAND）を利用。1-shotサブクエリとConjunctiveサブクエリを生成し、ビームサーチで最適な組み合わせを選択。カスタムC++検索エンジンと代替評価指標を使用。
* **アーキテクチャ/アルゴリズム:** ビームサーチ。カスタムC++検索エンジン。
* **テクニック:**
    * **クエリ形式:** マジックを利用。サブクエリをORで結合。共通トークンを持つサブクエリをマージしてトークン数節約。
    * **カスタム検索/評価:** Whooshの代わりに自作C++検索エンジンを使用。評価指標AP@50を、FPを含む場合も確率的に考慮する代替指標 `score2(n, m, p)` で近似し、これを最大化。検証用テストセットは`len(cpc_codes) > 0`でフィルタリング。
    * **候補生成 (n-shot):** 単一特許のみをヒットさせる単語またはAND結合（例: 2つのCPCコード）を事前計算。
    * **候補生成 (Conjunctive):** 複数のPositive、0個のCertain Negative、最大`l`個のPotential Negativeをヒットするような2-3トークンのAND結合をDFSで探索。Certain Negativeを避けることで効率化。
    * **サブクエリ選択:** ビームサーチ（幅W=100）で、トークン数ごとに `score2` を最大化するサブクエリの組み合わせを探索。

**[7位](https://www.kaggle.com/competitions/uspto-explainable-ai/discussion/522199)**

* **アプローチ:** 「マジック」（特殊文字 `~` をスペース代替）を利用し、トークン数制限を回避。単純なタイトル検索ベースライン。
* **アーキテクチャ/アルゴリズム:** テキスト検索（類似度計算）。
* **テクニック:**
    * **マジック:** `~` をスペースの代わりに使うことで、`ti:"word1~word2~..."` のようなフレーズ検索を1トークンとして扱わせる。
    * **クエリ生成:** このマジックを用いて、ターゲット特許のタイトル（最大25個）を完全一致で検索するクエリ (`ti:"title1_word1~..." OR ti:"title2_word1~..." OR ...`) を生成。
    * **高速化:** cudf-pandasを用いてGPUで処理し高速化（1分で実行可能）。

**[10位](https://www.kaggle.com/competitions/uspto-explainable-ai/discussion/522208)**

* **アプローチ:** 「マジック」は不使用？ 各テスト行について、関連する(cpc, ti, ab, detd)のペアを作成し、それらをソート・マージしてトークン数を節約したORクエリを生成。
* **アーキテクチャ/アルゴリズム:** ルールベースのクエリ構築？
* **テクニック:**
    * **ペア候補生成:** 各ターゲット特許に関連する(cpc, ti, ab, detd)のペアを抽出？ 各ペアがテストセット内の他の特許にヒットせず、かつテスト外特許へのヒットがテスト内特許より多くないペアを選択？
    * **トークン数節約:** 同じトークンを含むペアをマージする。（例: `(cpc:a cpc:b) OR (cpc:a cpc:c)` を `(cpc:a (cpc:b OR cpc:c))` にする）。
    * **検証:** 信頼できる検証セットの構築に苦労。最終的にはWhooshインデックスや全メタデータを使わずに解いた？
